GIT
====
    提交
    ====
        git commit    # git会调用vim来让你输入信息，适合较多信息输入的场合
        git commit -a 指的是把当前工作目录中没有被git add添加的文件也提交到本地仓库，不推荐这个选项，应该先git add -A在git commit [-m]

        删除指定提交
        ===========
            假设你有c1~c5五个提交，你要删除c5这个提交

            git log --oneline
                eb6a3dd (HEAD -> master) c5
                234ad32 c4
                269f234 c3
                bad34cd c2
                245cf8c c1

            git rebase -i <245cf8c>   # git要指定一个起点的，这里以c1为起点，你也可以以其它为起点
                # 此时弹出vim编辑器，内容大致是：开头几行字描述着各个提交该保留还是删除，下面的字讲的是所有可用的操作是什么意思
                pick bad34cd c2
                pick 269f234 c3
                pick 234ad32 c4
                pick eb6a3dd c5

                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala

            # 你想删除c5提交，只需把c5前面的pick改成drop即可。更改之后如下：
                pick bad34cd c2
                pick 269f234 c3
                pick 234ad32 c4
                drop eb6a3dd c5

                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala

            # vim保存退出即可

            # 注意，这个命令还有另外一个功效：它可以删除那种没有任何分支指向的提交，方法是你git rebase -i <...> 以后弹出的vim编辑器什么都
              不改，直接退出

    分支
    ====
        git checkout -b <新的branch>  # 创建一个新的分支，然后立马切过去
        git branch -d <要删除的分支名字>        # 删除本地分支
        git push origin --delete <要删除的分支名字>     # 删除远程分支。注意：<要删除的分支名字> 是直接写名字的，比如remotes/origin/bugfix这个分支你只要写bugfix就行了

    合并
    ====
        git merge -e --no-ff   # -e 合并后可以先看一下改了哪些再提交；--no-ff 不使用fast-forward合并策略，虽然git默认使用这种策略，但是
                               # 不推荐，应为这种策略合并后不会创建新的节点

    删除未被跟踪的文件，delete untracked files
    ==========================================
        # 删除 untracked files
        git clean -f

        # 连 untracked 的目录也一起删掉
        git clean -fd

        # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）
        git clean -xfd

        # 在用上述 git clean 前，强烈建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删
        git clean -nxfd
        git clean -nf
        git clean -nfd

    删除已经加入跟踪的文件
    ====================
        # 比如.cproject这个文件已经加入版本跟踪系统了，你想把它从版本跟踪系统中移除，但仍然让它留在文件系统中
        git rm -nr --cached .cproject  # 注意移除掉了以后别手贱又输入git add -A加回来

    查看版本库中的所有文件
    ====================
        git ls-tree <分支名> --name-only

    推送
    ===
        git push origin master      # 推送本地的master分支
        git push origin bugfix:bugfix  # 推送本地的bugfix分支(冒号前面)到远程的bugfix分支(冒号后面)，如果远程不存在bugfix分支会自动创建
        git push origin --tags      # 推送本地的所有标签


正则表达式
==========
    正则表达式 [^a]  指的是匹配非a的字符串，[^abc] 匹配的是非a且非b且非c的字符串，val\s*=[^=] 匹配的是val=后面不是=的字符串

    正则表达式的一些例子：
    =====================
        (typedef|#define).*uint8_t          ---  typedef或者#define的后面跟上uint8_t
        (?<=#define\s*VERSION\s*)\".*\"     ---  匹配#define VERSION "128-v173"中的"128-v173"

SHELL脚本
=========
    读取二进制文件
    ===============
        od -t xC -w<列数> <文件名>

            -t      指定格式
            x       16进制格式
            C       字节格式
            -w      一行显示几列

        od --traditional -d

            --traditional       以传统方式接受参数(od可以以好几种方式接受参数)
            -d                  每两个字节组成一个十进制数

    文本替换命令
    ============
        sed -i 's/idata//g' Mifare.c   # 把Mifare.c中的idata全部去掉

        # find命令
        find . ! -name 'port.h'   # 查找不是port.h的文件
        find . -regex ".*dat"     # 查找当前目录下的所有.dat文件，注意使用-regex(正则表达式)以后，匹配的不只是文件名
                                    而是绝对路径
        find . \( ! -name "*.dat" \) -a \( ! -name "*.sh" \)    # 当前目录找不是.dat也不是.sh文件的文件

    shell的延时
    ===========
        sleep : 默认为秒。
        sleep 1s 表示延迟一秒
        sleep 1m 表示延迟一分钟
        sleep 1h 表示延迟一小时
        sleep 1d 表示延迟一天

        usleep表示微秒

    date命令
    ========
        tm=`date --date="1 hour ago" +%Y%m%d%H%M`       # 获取当前时间的一小时以前的时间
        echo $tm

        tm=`date --date="20181009 1045 1 hour ago" +%Y%m%d%H%M`     # 获取指定时间一小时以前的时间
        echo $tm

    把字符串写入文件
    ================
        如果字符串只有一行
        ==================
            这不难

                echo "111 222" > a.txt
            或者这样：
                for line in "111 222"
                do
                    echo $line >> a.txt
                done

        如果字符串有多行
        ================
            这个知识点很隐蔽，因为刚学这个的人肯定会以为可以像处理单行字符串那样，不行的。

    字符串去重
    =========
        sort -u     # 去除重复只保留一个然后排序
        uniq        # 只去除连续的重复

        引申
        ====
            ls -R | grep -oE '\.[0-9a-zA-Z_\.]+$' | sort -u     # 列出一个目录下的所有文件类型
            
    列出一个目录下的全部文件
    ======================
        ls -lR | grep -E "^-" | grep -oE ":\w\w .*$" | grep -oE " .*$"
        
    grep
    ====
        grep -nrE --include=*.{c,h} "mf_"    # -n：打印行号；-r：递归查找；-E：正则表达式；--include=*.{c,h}：去.c和.h文件里面找；"mf_"：以mf_开头的东西


    文本编辑命令
    ============
        awk -F" " '{print NF}' read.txt

            -F" "                指定分隔符是空格
            '{print NF}'         打印每一行的列数
            cat yy.txt | awk '{printf "%-30s%-15s\n",$1,$2}' > yy2.txt
                                 把yy.txt中的第一第二列按固定的缩进打印并输出到yy2.txt
                                 # %-30s表示输出字符串,宽度30位,左对齐.%-15s用来指定第二列的,左
                                 # 对齐,宽度15.两个百分号之间可以没有空格.使用\n对每一行的输出加上换行符
                                 # 如果要表示第10列及以上，用$(10),$(11)...

C语言
===================

    库函数获取毫秒
    ==============
        #include <stdio.h>
        #include <sys/timeb.h>

        long long getSystemTime() {
            struct timeb t;
            ftime(&t);
            return 1000 * t.time + t.millitm;
        }

        int main() {
            long long start=getSystemTime();
            sleep(5);
            long long end=getSystemTime();

            printf("time: %lld ms\n", end-start);
            return 0;
        }

    库函数延时函数
    ===================
        sleep()         秒延时
        usleep()        微秒延时


    编程坑点
    =========
        * 取局部变量的地址要注意内存释放的问题。当你使用局部变量的地址引用局部变量时，局部变量可能早就被释放了，所以
          如果非要，记得局部变量加volatile

        * 全局变量的读写要注意共享问题。例如你在读取一个很长的全局变量时，假如另一个程序打断了你的当前代码并修改了全局变量，后果会怎样


PYTHON
======

    编程例子：
    =========
        打印字母A到Z：
            for i in range(ord('A'), ord('Z')):
                print(chr(i))


emWin
=======
    MESSAGEBOX_Create, GUI_MessageBox都是创建消息框函数，区别是前者能重写回调函数(但是回调函数只接
    受WM_PAINT这一个消息)，后者不能



STM32HAL库
==========

    怎样初始化一个外设
    ==================
        以串口3为例：
        1. 定义一个串口3的全局句柄USART_HandleTypeDef xxx，后续所有的操作都要用到它
        2. stm32f7xx_hal_msp.c文件的HAL_USART_MspDeInit函数添加串口3的默认初始化函数，一般是关时钟，中断和GPIO默认初始化
        3. stm32f7xx_hal_msp.c文件的HAL_USART_MspInit函数添加串口3外围的初始化函数，包括串口3的时钟和相应的GPIO时钟使能，
           GPIO初始化，串口3的中断初始化
        4. main.c或者其他哪个文件都行，写一个串口3真正的初始化函数，包括波特率，校验位那些

    怎样使用一个中断
    ================
        以串口3为例：
        1. stm32f7xx_it.c文件添加USART3_IRQHandler函数
        2. 重写HAL_UART_XXXtCallback函数
        3. 使用HAL_UART_Receive_IT函数注册中断接收数组
        4. 别忘了在HAL_UART_MspInit中使能串口中断

    其他
    ====
        HAL库的头文件只需一个#include "stm32f7xx_hal.h"即可


Keil MDK
========

    优化选项
    ========
        当前MDK(5.26)共有4个优化选项：O0, O1, O2, O3，千万别用O0，有问题的

    怎样重定向printf
    ===============
        1. 添加段代码
        ============
            #include <stdio.h>
            int fputc(int ch, FILE *f)
            {
                uint8_t temp[1] = {ch};
                HAL_UART_Transmit(&huart1, temp, 1, 2);
                return(ch);
            }

        2. USE Micro Lib
        ================
            具体略


GCC
====

    链接
    ====
        把一个变量放到指定的段内
        =========================
            __attribute__((section("name")))        # name即是你要指定的段，名字随便取，可以带'.'号

            例如：
                int david __attribute__((section(".user.char.1"))) = 0x123;  # 把david这个变量放到".user.char.1"段中

        利用链接脚本导出符号
        ====================
            在C语言里面，你若想导出一个符号，必然要用extern。但是GCC的链接脚本允许你不用那种方法：

                # 链接脚本中定义好".user.char.1"段
                SECTIONS
                {
                    .text :
                    {
                        ...
                        *(.user.char.1)
                        ...
                    }
                }

                # C工程中定义一个位于".user.char.1"段的变量
                int david __attribute__((section(".user.char.1"))) = 0x123;

                # 此时david这个变量就变成全局变量了，你可以在工程的任意一个位置访问它而不需要extern。

                # 实际上，你还可以把链接脚本改成这样：
                SECTIONS
                {
                    .text :
                    {
                        ...
                        user_start = .;
                        *(.user.char.1)
                        *(.user.char.2)
                        *(.user.char.3)
                        *(.user.char.4)
                        user_end = .;
                        ...
                    }
                }
                # 这种情况适用于当你的自定义段很多的时候，你可以通过获取user_start和user_end的地
                # 址(即&user_start, &user_end)来访问到这个“数组”。Linux内核里面有大量应用

GDB
===
    x/32xb buf   # 查看buf内存
    info locals  # 查看局部变量
