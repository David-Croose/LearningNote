GIT
====
    提交
    ====
        git commit    # git会调用vim来让你输入信息，适合较多信息输入的场合
        git commit -a 指的是把当前工作目录中没有被git add添加的文件也提交到本地仓库，不推荐这个选项，应该先git add -A在git commit [-m]

        删除指定提交
        ===========
            假设你有c1~c5五个提交，你要删除c5这个提交

            git log --oneline
                eb6a3dd (HEAD -> master) c5
                234ad32 c4
                269f234 c3
                bad34cd c2
                245cf8c c1

            git rebase -i <245cf8c>   # git要指定一个起点的，这里以c1为起点，你也可以以其它为起点
                # 此时弹出vim编辑器，内容大致是：开头几行字描述着各个提交该保留还是删除，下面的字讲的是所有可用的操作是什么意思
                pick bad34cd c2
                pick 269f234 c3
                pick 234ad32 c4
                pick eb6a3dd c5

                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala

            # 你想删除c5提交，只需把c5前面的pick改成drop即可。更改之后如下：
                pick bad34cd c2
                pick 269f234 c3
                pick 234ad32 c4
                drop eb6a3dd c5

                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala
                # balabalabalabalabalabalabalabala

            # vim保存退出即可

            # 注意，这个命令还有另外一个功效：它可以删除那种没有任何分支指向的提交，方法是你git rebase -i <...> 以后弹出的vim编辑器什么都
              不改，直接退出

    分支
    ====
        git checkout -b <新的branch>  # 创建一个新的分支，然后立马切过去
        git branch -d <要删除的分支名字>        # 删除本地分支
        git push origin --delete <要删除的分支名字>     # 删除远程分支。注意：<要删除的分支名字> 是直接写名字的，比如remotes/origin/bugfix这个分支你只要写bugfix就行了
        git branch -f <分支名> <SHA1>      # 强制移动一个分支到一个提交

    合并
    ====
        git merge -e --no-ff   # -e 合并后可以先看一下改了哪些再提交；--no-ff 不使用fast-forward合并策略，虽然git默认使用这种策略，但是
                               # 不推荐，应为这种策略合并后不会创建新的节点

    删除未被跟踪的文件，delete untracked files
    ==========================================
        # 删除 untracked files
        git clean -f

        # 连 untracked 的目录也一起删掉
        git clean -fd

        # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）
        git clean -xfd

        # 在用上述 git clean 前，强烈建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删
        git clean -nxfd
        git clean -nf
        git clean -nfd

    删除已经加入跟踪的文件
    ====================
        # 比如.cproject这个文件已经加入版本跟踪系统了，你想把它从版本跟踪系统中移除
        
        git rm -nr --cached .cproject    # -n：这只是看而已，实际并不移除；-r：递归移除；--cached：从跟踪系统中移除，但仍保留在文件系统中
        
        注意：
            * 只要有“-n”这个参数就不会删除，只是打印出哪些文件会被删除而已，你如果真的十分确定删除了就去掉这个选项
            * 关于“.gitignore”失效的问题，“.gitignore”只能忽略未被跟踪的文件，假如有个文件先被加入跟踪了你才用“.gitignore”忽略它，那么“.gitignore”将失效。解决办法是：用git rm把那个文件取消跟踪，再git add -A


    查看已跟踪的所有文件
    ==================
        git ls-files                      # 列出所有已跟踪文件
        git ls-tree <分支名> --name-only   # 这个好像是列出working space中的所有文件，不建议用这个

    推送
    ===
        git push origin master      # 推送本地的master分支
        git push origin bugfix:bugfix  # 推送本地的bugfix分支(冒号前面)到远程的bugfix分支(冒号后面)，如果远程不存在bugfix分支会自动创建
        git push origin --tags      # 推送本地的所有标签
        git push -u origin develop  # 在远程创建一个新分支develop


正则表达式
==========
    正则表达式 [^a]  指的是匹配非a的字符串，[^abc] 匹配的是非a且非b且非c的字符串，val\s*=[^=] 匹配的是val=后面不是=的字符串

    正则表达式的一些例子：
    =====================
        (typedef|#define).*uint8_t          ---  typedef或者#define的后面跟上uint8_t
        (?<=#define\s*VERSION\s*)\".*\"     ---  匹配#define VERSION "128-v173"中的"128-v173"
        aaa\s*=[^=\r\n]*                    ---  匹配aaa后面带"="而不是"=="的字符串，也就是aaa这个变量的赋值语句

SHELL脚本
=========
    读取二进制文件
    ===============
        od -t xC -w<列数> <文件名>

            -t      指定格式
            x       16进制格式
            C       字节格式
            -w      一行显示几列

        od --traditional -d

            --traditional       以传统方式接受参数(od可以以好几种方式接受参数)
            -d                  每两个字节组成一个十进制数

    文本替换命令
    ============
        sed -i 's/idata//g' Mifare.c   # 把Mifare.c中的idata全部去掉

        # find命令
        find . ! -name 'port.h'   # 查找不是port.h的文件
        find . -regex ".*dat"     # 查找当前目录下的所有.dat文件，注意使用-regex(正则表达式)以后，匹配的不只是文件名
                                    而是绝对路径
        find . \( ! -name "*.dat" \) -a \( ! -name "*.sh" \)    # 当前目录找不是.dat也不是.sh文件的文件

    shell的延时
    ===========
        sleep : 默认为秒。
        sleep 1s 表示延迟一秒
        sleep 1m 表示延迟一分钟
        sleep 1h 表示延迟一小时
        sleep 1d 表示延迟一天

        usleep表示微秒

    date命令
    ========
        tm=`date --date="1 hour ago" +%Y%m%d%H%M`       # 获取当前时间的一小时以前的时间
        echo $tm

        tm=`date --date="20181009 1045 1 hour ago" +%Y%m%d%H%M`     # 获取指定时间一小时以前的时间
        echo $tm

    把字符串写入文件
    ================
        如果字符串只有一行
        ==================
            这不难

                echo "111 222" > a.txt
            或者这样：
                for line in "111 222"
                do
                    echo $line >> a.txt
                done

        如果字符串有多行
        ================
            这个知识点很隐蔽，因为刚学这个的人肯定会以为可以像处理单行字符串那样，不行的。

    字符串去重
    =========
        sort -u     # 去除重复只保留一个然后排序
        uniq        # 只去除连续的重复

        引申
        ====
            ls -R | grep -oE '\.[0-9a-zA-Z_\.]+$' | sort -u     # 列出一个目录下的所有文件类型

    列出一个目录下的全部文件
    ======================
        ls -lR | grep -E "^-" | grep -oE ":\w\w .*$" | grep -oE " .*$"

    grep
    ====
        grep -nrE --include=*.{c,h} "mf_"    # -n：打印行号；-r：递归查找；-E：正则表达式；--include=*.{c,h}：去.c和.h文件里面找；"mf_"：以mf_开头的东西


    文本编辑命令
    ============
        awk -F" " '{print NF}' read.txt

            -F" "                指定分隔符是空格
            '{print NF}'         打印每一行的列数
            cat yy.txt | awk '{printf "%-30s%-15s\n",$1,$2}' > yy2.txt
                                 把yy.txt中的第一第二列按固定的缩进打印并输出到yy2.txt
                                 # %-30s表示输出字符串,宽度30位,左对齐.%-15s用来指定第二列的,左
                                 # 对齐,宽度15.两个百分号之间可以没有空格.使用\n对每一行的输出加上换行符
                                 # 如果要表示第10列及以上，用$(10),$(11)...

    清空一个文件
    ===========
        cat /dev/null > dat.bin

C语言
===================

    库函数获取毫秒
    ==============
        #include <stdio.h>
        #include <sys/timeb.h>

        long long getSystemTime() {
            struct timeb t;
            ftime(&t);
            return 1000 * t.time + t.millitm;
        }

        int main() {
            long long start=getSystemTime();
            sleep(5);
            long long end=getSystemTime();

            printf("time: %lld ms\n", end-start);
            return 0;
        }

    库函数延时函数
    ===================
        sleep()         秒延时
        usleep()        微秒延时


    编程坑点
    =========
        * 取局部变量的地址要注意内存释放的问题。当你使用局部变量的地址引用局部变量时，局部变量可能早就被释放了，所以
          如果非要，记得局部变量加volatile
        * 内存、中断、电压（低功耗）是全局的，任何一个函数都要考虑这三个方面
        * 要有错误处理（日志，打印等）程序，switch和if要做好default和else的检查，空的else最好用/*nothing here*/注明
        * 小心函数的重复运行问题，比如task_create反复执行会创建出很多个一样的任务
        * 全局变量和硬件如果被多任务，中断共享要做好保护措施
        * 系统的初始化也有学问，系统的各个软硬件，哪些要在哪些前面
        * 小心死锁问题，死锁也能导致死机，发生原因一般是嵌套锁
        * 建议加看门狗
        * 测试代码的时候要记录栈使用情况，防止栈溢出
        * 小心C语言的宏定义，比如这个：#define SET_MODE(hd, mode)     led_handles[(hd)].mode = (mode)
          当你这样调用时：SET_MODE(1, sta)，展开成了led_handles[(hd)].sta = sta，你本想改变mode成员，结果改到sta成员去了



PYTHON
======

    编程例子：
    =========
        打印字母A到Z：
            for i in range(ord('A'), ord('Z')):
                print(chr(i))


emWin
=======
    MESSAGEBOX_Create, GUI_MessageBox都是创建消息框函数，区别是前者能重写回调函数(但是回调函数只接
    受WM_PAINT这一个消息)，后者不能



STM32HAL库
==========

    怎样初始化一个外设
    ==================
        以串口3为例：
        1. 定义一个串口3的全局句柄USART_HandleTypeDef xxx，后续所有的操作都要用到它
        2. stm32f7xx_hal_msp.c文件的HAL_USART_MspDeInit函数添加串口3的默认初始化函数，一般是关时钟，中断和GPIO默认初始化
        3. stm32f7xx_hal_msp.c文件的HAL_USART_MspInit函数添加串口3外围的初始化函数，包括串口3的时钟和相应的GPIO时钟使能，
           GPIO初始化，串口3的中断初始化
        4. main.c或者其他哪个文件都行，写一个串口3真正的初始化函数，包括波特率，校验位那些

    怎样使用一个中断
    ================
        以串口3为例：
        1. stm32f7xx_it.c文件添加USART3_IRQHandler函数
        2. 重写HAL_UART_XXXtCallback函数
        3. 使用HAL_UART_Receive_IT函数注册中断接收数组
        4. 别忘了在HAL_UART_MspInit中使能串口中断

    其他
    ====
        * HAL库的头文件只需一个#include "stm32f7xx_hal.h"即可
        * 小心DMA，例如你在一个DMA传输函数执行结束后读取内存，这个内存可能仍被DMA控制


Keil MDK
========

    优化选项
    ========
        当前MDK(5.26)共有4个优化选项：O0, O1, O2, O3，千万别用O0，有问题的

    怎样重定向printf
    ===============
        1. 添加段代码
        ============
            #include <stdio.h>
            int fputc(int ch, FILE *f)
            {
                uint8_t temp[1] = {ch};
                HAL_UART_Transmit(&huart1, temp, 1, 2);
                return(ch);
            }

        2. USE Micro Lib
        ================
            具体略


GCC
====

    链接
    ====
        把一个变量放到指定的段内
        =========================
            __attribute__((section("name")))        # name即是你要指定的段，名字随便取，可以带'.'号

            例如：
                int david __attribute__((section(".user.char.1"))) = 0x123;  # 把david这个变量放到".user.char.1"段中

        利用链接脚本导出符号
        ====================
            在C语言里面，你若想导出一个符号，必然要用extern。但是GCC的链接脚本允许你不用那种方法：

                # 链接脚本中定义好".user.char.1"段
                SECTIONS
                {
                    .text :
                    {
                        ...
                        *(.user.char.1)
                        ...
                    }
                }

                # C工程中定义一个位于".user.char.1"段的变量
                int david __attribute__((section(".user.char.1"))) = 0x123;

                # 此时david这个变量就变成全局变量了，你可以在工程的任意一个位置访问它而不需要extern。

                # 实际上，你还可以把链接脚本改成这样：
                SECTIONS
                {
                    .text :
                    {
                        ...
                        user_start = .;
                        *(.user.char.1)
                        *(.user.char.2)
                        *(.user.char.3)
                        *(.user.char.4)
                        user_end = .;
                        ...
                    }
                }
                # 这种情况适用于当你的自定义段很多的时候，你可以通过获取user_start和user_end的地
                # 址(即&user_start, &user_end)来访问到这个“数组”。Linux内核里面有大量应用

GDB
===
    x/32xb buf   # 查看buf内存
    info locals  # 查看局部变量



ubuntu，树莓派，安卓
==============

    su失败的解决办法
    ================
        问题：
            pi@raspberrypi:/ $ su
            密码：
            su：鉴定故障

        解决办法：
            sudo su

    开启SSH服务
    ==========
        ubuntu默认是不使能SSH的，你得自己安装配置（树莓派是安装了SSH的，只是没有使能）

        sudo apt-get install openssh-server
        sudo systemctl restart ssh

    树莓派改软件源
    =============
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
        sudo vi /etc/apt/sources.list
            把以前的都删掉，加入deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi
            保存退出
        sudo cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak
        sudo vi /etc/apt/sources.list.d/raspi.list
            把以前都删了，加入deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui
            保存退出
        sudo su
        apt-get update && apt-get upgrade
        
    ubuntu改软件源
    =============
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
        sudo echo > /etc/apt/sources.list       # 清空原本的配置文件
        去中科大的官网下载一个sources.list文件（可以输入"ubuntu"查找），复制里面的内容到/etc/apt/sources.list就行了
        sudo apt-get update
        sudo apt-get upgrade


    查看有哪些设备连入了本设备的热点
    =============================
        ip neigh

    搭建ftp服务器
    ============
        ubuntu:
            sudo apt-get install vsftpd
            sudo vim /etc/vsftpd.conf
                把#write_enable=YES改成write_enable=YES
                保存退出
            sudo service vsftpd restart     # 当然用sudo systemctl restart vsftpd或者sudo /etc/init.d/vsftpd restart也可以

        windows:
            ftp://<ubuntu的IP地址>  # 例如ftp://192.168.43.254
            账号：pi
            密码：<pi>的密码

        结果：
            ubuntu的/home/pi目录共享到了windows上。有关vsftp的所有配置都在/etc/vsftpd.conf文件中
            你可以用man vsftpd或者man vsftpd.conf获取帮助

    搭建samba服务器
    ==============
        ubuntu:
            sudo apt-get update
            sudo apt-get install samba samba-common-bin
            sudo vim /etc/samba/smb.conf
            # 在文件的最底部添加这段代码。注意"="两边可以带空格；好像不可以用tab来当空格
                [pi]                    # "pi"你可以换成自己的名字
                    path = /home/pi     # 共享目录
                    writable = yes
                保存退出
            sudo smbpasswd -a pi        # 往samba中添加用户pi，系统会提示输入密码。注意这个用户必须是ubuntu真实存在的用户，你可能需要user add pi
            sudo service smbd restart   # 当然用sudo systemctl restart smbd或者sudo /etc/init.d/smbd restart也可以

        windows:
            文件管理器找到"网络>>RASPBERRYPI>>pi"，输入账号pi以及他的密码即可

    搭建nfs服务器
    ============
        Windows挂载nfs非常卡，还不支持中文，不建议使用

        ubuntu:
            sudo apt-get install nfs-kernel-server      # 这步你可能并不需要，因为很多Linux发行版都是自带nfs的。你可以先看看/etc/export是否存在，如果存在则说明安装了
            sudo vim /etc/exports
                末尾添加这个
                /home/pi    *(rw)     # "/home/pi"是你要共享出去的路径；"*"指的是任何网段的主机都可以访问你的nfs；"(rw)"指的是别人可读可写
                保存退出
            chmod 777 /home/pi
            sudo systemctl restart nfs-kernel-server.service    # 当然你用sudo service <服务名> restart或者sudo /etc/init.d/<服务名> restart也可以

        windows:
            控制面板--->程序--->打开或关闭Windows功能。把NFS服务子项全部勾选，"基于UNIX的应用程序子系统"勾选
            cmd窗口输入：mount \\192.168.43.254\home\pi x: 或者 文件管理器--->映射网络驱动器--->填入\\192.168.43.254\home\pi--->确定
            打开文件浏览器，你可以看到ubuntu的nfs挂载上来了，但是是只读的，尽管你的ubuntu已经规定可写了，网上有解决办法，但是我试了不成功
            如果卸载挂载，cmd窗口输入：umount -a -f


